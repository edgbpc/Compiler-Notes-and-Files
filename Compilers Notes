
/*Compilers - Week 1 Wednesday

All homework due 6:55 PM on due date
Will discuss project and quiz next class period
Submitted on Canvas

Projects submitted on delmar
Projects due at 11:59 on due date
Include README
Can use C/C++

Programming Standards
- generally applies to C, C++, Java, etc
- see file on Programming Standards on Canvas

assignment vs operator
operator - creates an expression
  expressions have types, values and evaluates


  y = 1
  x = y = 3 //only compiles of assignment in an operator


  assignment is associative.  evaluates left to right


Week 2 - Monday 1/28

Modules provide information for entire project (headers)
Sources implement headers
headers - information provided "what is exported".  information about the functions, variables, etc


seperate source files always compiled one at a time

source -> preprocessor (everything with # processed (ex - #include stdio.h, macros) 
telling compiler that using elements (information from the library) from stdio not the actual library; library linked later

on delmar 

gcc -E *.c > y.i will produce the preprocessor file and redirect to file

... = variable number of parameters

compiler uses the .i file - - on delmar, .i not created as a file unless specified by -E, otherwise, gcc will continue to compile


Linker - connects multiple compiled files into a single executable.  Ex - connects printf in source to the implementation in the library (external linkage)

most errors come from the compiler - syntax, undefined variables
: undefined reference to 'printff'
Linker error - collect2: error: ld returned 1 exit status (ld is linker error)

if no main - shell cannot start the program.  cannot call main as a function

internal linkage - idea to prevent linker from connecting header info to other modules 
	a helper function defined in source but not in the header, is hidden from the linker and only available to that source in which it was defined

define the helper with static inside the source that needs to use the helper.  





for each source, 1 header file.

** possible error - including same header info more then once

prevention:

assume filename.h

#ifndef FILENAME_H // if not defined
#define FILENAME_H //then define

// content

#endef


typess and macros do not exist once the linker starts


REVIEW FLOATING POINT REPRESENTATION VS INTEGAR REPRESENTATION

In a 8 bit number, the first 4 of bits of floating point =/= the 4 bits of an integer number


PROJECT 0 -

ctrl+d to simulate end of file

Standard template library. (Stl)

c++ strings


Abstract syntax tree

Adam ala ada Jim ala Susan George Georg john



0		4: Adam
		   john
1	3: Ala		5: Susan
	   Ada		   Georg
	   Jim
2				6: George


Print preorder traversal - visit node, process node before traveling left, then down (if nothing left or right returns up a node and checks right)
4 Adam John				4 - root
 3 Ala Ada Jim				3 - child of root, has no children
 5 Susan Georg				5 - child of root, has a child 6
   6 George



MUST USE FUNCTION NAMES IN ASSIGNMENTS

Write program to only read from file

If keyboard input, take input from keyboard and save to file then read file

If redirection -  //name of program is 1st argument argc =1
Int main(int argc, char * argv[]){

//process # of argument
If argc > 2  //error too many arguments

If argc == 2  {//file basename given
	string base = argv[1]
	base += ".sp19"

	FILE *fp = fopen(base, "r")
	//test if not successfully open
}

If argc == 1 {//keyboard or the redirection
	fp = stdin

}
String data

Fscanf(fp, "%s", data)  //fp is file pointer either from the file or the keyboard, but doesn't matter


}

Monday 2/4

reviewed basic introductions to languages

semantics - process data by the rules and assignment by rules

programming languages evolved with restrictions.  natural lanaguages did not
4 categories of laguages

type 3 -> regular, linear expressions: algorithms
type 2 -> context free: BNF
type 1 -> difficult to write algorithms, static semantics
type 0 -> turing machines, algorithm that cannot be built.  won't write languages for this level


type 2 and 3 is where we write programming languages
compontents of languages written in type 2 and then others considered case-by-case

https://drona.csa.iisc.ac.in/~deepakd/atc-2013/seminars/presentation_1.pdf

Wednesday 2/6

first C++ compilers compiled to C then to machine code

languaged must be precisely defined and unambigous
should be able to look at code and tell if it will run or not
high level languages give portability (multiple machines - mostly)

languages, more seperated -
syntax - what is proper structure
semantics - what's the expression mean

Syntax -
start with alphabet - set of valid characters
grammar - rules for generating/recongizing valid strings of the language (tokens)

there are restrictions

ex . in C must have (..) after an if

trivial ex - L1 = 01* // every string in lanaguage must start with 01
valid strings -- 0111, 01, 01101 but not 10

tokens can be keywords, symbols, letters, operators, etc

diff in type 1 and type 2 categories -
natural languages are context sensitive (leads to ambigouty)
programing languages are context free

bindings -

global x
local x

x = 5
which x?  depends on if dynamic or static scoping
if static scoping - we know which x is assigned 5, compiler can too
if dynamic - can't answer

static -> compilation time
dynamic -> runtime

variables have attributes that have to be assigned. if done at runtime or compiler, depends on language
    type, name, address, value, lifetime (scope)

ex language
type 1 -> varialbes
type 2 -> the parser
type 3 -> construct keywords

BNF :
terminals/tokens and non-terminals

tokens: lower case letter or no brackets
terimanal: upper case or use < >

BNF is a set of productions
<program> -> program being <variables> <statements> end
<variables> -> var id; <variables> | e  // <variables> is recursion.  recursion requires a base (e)) e = empty
<statements> -> <stat>;{<stat>;} //must have at least 1 statement and then repeats any number of times, incuding 0
...
<ifStat>-> if <cond><state>{else <stat>}
 this does not say what program does, only says what is possible

ex -
program
    begin
        var x;
        statement;
    end



Extended BNF -
added repeats
{x} - repeat any number of times -- 0, 1 ... times
[x] - means optional x

Static vs dynmaic linking

static - put all the files together
Unix/linux - went with idea that size doesn't matter; speed does.  uses static

dynamic -
Windows - size matters
dll -- dynmically linked library



Compiler analyzes source and puts it together to make the target

Machine Indepedent -
High level languages (C++, etc) - processed indepedently of the machine
Machine Depedent -
when the code changed to machine language


parser - use BNF to check for syntax errors
scanner translates from characters to tokens
BNF  expressed in tokens

Homework review

<for> -> for ( <exp>  ; <exp>  ; <exp>  ) <statement> | for -> ( <exp> ; <exp>  ; <exp> ) <block>
OR
<for> -> for ( <exp> ; <exp> ; <exp>  ) <statmentORblock>
<statmentORblock> -> <statement> | <block>

expressions vs statements
expressions evaluate and have types


regular languages -> smallest subset of categories of languages

L - (101)*(00)*(01)+ or (101)*(00)*01(01)*

infinite # of strings possible


inteperters -

allows programs to be built in languages other then the machine language of the computer that is building the program

interperters leads to abstract machines
run without compliation

write interpter in a high level language that you can compile

IE write and compile in C

java virtual machine -> compiler produces bytecode
    reason? -- portability at synthesis.  person only needs virtual machine to run
            -- compete with microsoft

    pascal did this too
        for reusability

time/space complextity

Quiz 2 review

A block :

{
    x = 1 ;
}

{
    int x;
    x = 1;
}
<block> --> {  <variable><statement> }
<statement> --> <statement><statements> | <statements>

https://en.wikipedia.org/wiki/Tombstone_diagram


Java Model -

Java source -> Compiler -> Bytecode -> Executes in Java Virtual machine

re-write system to not use the JVM in compliation or in execution of final program

run source through the executable of that source to get a new compiler (bootstrapping)

Lexical Analysis (scanner) -> takes characters and turns into tokens

Σ^chars -> Σ^tokens

significant digits -- scanners used to cut off after set number of characters in a identifier declaration
IE DOS - 6 characters where considered significant.  distanc == distance

token include line number

overloaded tokens - ex in C * could be multiplication or deference.  Scanner can't determine

symbol tables used to be used in compilers but no longer due to scopes

Finite automation - requires memory
algorithm does not assume infinite memory
has a starting point, must terminate, have steps

graph representation
must be labed and directed

  a
O--->O

BNF extension lecture
-- describes the valid syntax ... ex - is semicolon in the right place?

start with what are the tokens

BNF needs
1) tokens = terminals
    example tokens -> +, if, while {
2) non-terminal(s) <  >, uppercase letters.  says what we are defining.  As needed
    example - <block>
3) set of prodctions   { ... }     ->
{ <  >  -> ( Terminal |  < >)* }

BNF is finished with non-terminal is on the left

Example:



defining a program wiht BNF

<program> -> <globals> <functions>
<globals> -> int ID;<globals> | int ID; |  ε
<functions> -> <func><functions>|<func>
<func> -> int ID (<args>) <block>
<block> -> { <vars> <stats> }        -----> the answer for the quiz
<stats> -> <stat><stats> | <stat>   ----->
<stat> -> <expr>; | <block> | <ctrlStat>
<expr> ->
<ctrlStat> ->



note:
int is a keyword/token
in BNF use recursion for repetition
ID = indentifier
 ε = empty

--

back to lexical analysis

ID = L (L|D|_)*
Σ = { L, D, _, WS }
good: x, n, x23b, y
bad: 2a, 3x, -x

Type 1 -  able to use regular expressions to define tokens

Type 2 - graph
    need states

ID = L(L|D|_)*
Σ = { L, D, _, WS }

how to modify to say ID must have at least length 2

always go from state to another state
need new state to count letters

state (loop on WS) --- L --> state --- L\D\_--- L ---> state --- WS ---> Final State

Nondeterminism
    do not have enough information to make a decision
    in computer science, if you don't have enough information, have to account of multiple situations

finite automata can be deterministic or non-determinisitic


in a graph, unlabel is a jump to another state

non-determistic -> allows for more options (more powerful?)
can convert any any non-deterministic to deterministic (so not more powerful?)

https://www.tutorialspoint.com/automata_theory/ndfa_to_dfa_conversion.htm

Look ahead required when spaces allowed -> more discussion to follow on lookahead

generally keywords are reserved and look like identifers

token in three parts:

[Tk?|Which|Line#]

scanner -> reads words and gives tokens

using regular expressions/regular languages = fine automata

getting started on scanner-
design directional graph
graph traversals

graph  as an array representation
2d array

                Alphabet = {L D _ >= WS}  - every letter, digit, _, >, +, >=, , tab
               L   D    _   >    =    WS
            ---------------------------------
       s1 |   s3 | s5 | E | s2 | E  |  s1
       s2 |  fs> |fs> |fs>|fs> |s4  | fs>
       s3 |  s3  | s3 |s3 |fsID|fsID| fsID
       s4 |
       s5 |
          |
          |
          |
          |
nodes     |
(states)
                E = error

        create 2D array with some kind of base type
        ie double A[5] -> array of 5 doubles
        state tells you what row to go to.  s3 = row 2.. IE int 2 errors represented as negatives
        or array of structures
        finals states ints > 1000

drive code -
implemment
loop until error or final state
3 options - keep lookng, error, or final state

BNF Quiz Clarifications:
BNF must common problems
Functions and then more functions
WRONG - <functions> -> <type>ID(...){...}}
doesn't support multiple functions

Most Common Mistakes:
__________
|M      N| -> no such thing as compilers for 1 machine language to another machine language
---   ----
   |C|
   ---     -> but the quiz question was on compilers not interrupters

  ____
  |M |  -> interrupter
  |N |
  ----
 ______
(prog  )   -> don't write program source in machine
 | M  |
 ------

input source and output source always the same
applies for when writing a compiler and getting a new computer


Back to lexical analysis --
Σchar ->Σtoken
(char)+ -> 1 token  --> at least 1 character into a token

P1 suggestions
main.c
---------
| same code as P0
|
|
|
| //testscanner()
|

scanner.c
-----------
| scanner() {..}
|
| //other helpers
|
|
|

testScanner.c
---------
|
|
| testscanner() {
| //loop until EOFtk
| //scanner()
| //print Tk (for testing)
| }

Scanner Suggesstion

file.sp19 -------> SCANNER  -------> Token
   read characters 1 at a time


file.sp19 ->  FILTER 1 --> SCANNER FA  -> FILTER 2 ----> Token

helpers:

filter: gets data, keeps some, discards some, maybe make small changes
Filter 1: Take out comments, count lines, map characters to column
Filter 2: Pass  non-identifers through, compare identifers to list of keywords and
report keywords if match, otherwise pass idenitifer

CFGParsing
static semantics -- BNF cannot express
   Type 2 - Context Free Grammer (BNF)
    generic way of describing a language
    tokens (words)
    nonterminals (sentanaces, paragraphs)
    always a beginning non-terminal... starting point
    productions

In BNF - always 1 non terminal on the left
IE
<function> ->
not
<function>ID<stats> ->

https://en.wikipedia.org/wiki/Turing_machine

programs a program when only tokens

"Program correct with respect to its grammar"

parsar will say if program is ok in terms of syntax

Compilers "peek" into the source so it generates 1 matching program to check syntax
via Parse/Abstract tree


